\documentclass[a4paper,10pt]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{eso-pic} 
\usepackage{mathtools}

\newcommand\BackgroundPic{% 
   \put(0,0){% 
      \parbox[b][\paperheight]{\paperwidth}{% 
         \vfill 
         \centering{\includegraphics{images/videoChop.png}} 
         \vfill 
      } 
   } 
} 

\title{Medienprojekt I \\ Thema: Videochop}
\author{Michael Duve, Felix Maulwurf, Angelina Staeck}
\date{29.11.2014}
\begin{document}
\maketitle
\newpage
\AddToShipoutPicture{\BackgroundPic}
\tableofcontents
\newpage
\section{Projektteilnehmer}
\subsection{Michael Duve}
\begin{center}
\includegraphics[height=90px, width=90px]{images/micha.jpg}\\
\textbf{Medieninformatik Fachsemester 4} \\
\vspace*{1.5mm} 
HTML5, CSS3, JS, PHP, MySQL, Webapps iOS,\\
Grundkenntnisse Server,
Java, min. Python
Photoshop, Illustrator, InDesign
Repositories (Git, Mercurial), JIRA, Documentation
\end{center}
\subsection{Felix Maulwurf}
\begin{center}
\includegraphics[height=90px, width=90px]{images/felix.jpg}\\
\textbf{Medieninformatik Fachsemester 4} \\
\vspace*{1.5mm} 
HTML5, CSS3, JS, PHP, MySQL, Java,\\
Photoshop, Illustrator, After Effects,
3DSMax,\\
Cinema4D, Office, Repositories (Git), LaTeX
\end{center}
\subsection{Angelina Staeck}
\begin{center}
\includegraphics[height=90px, width=90px]{images/angi.jpg}\\
\textbf{Medieninformatik Fachsemester 4} \\
\vspace*{1.5mm} 
HTML5, CSS3, JS, PHP, \\
Java, SQL, Illustrator, Photoshop
\end{center}
\newpage
\section{Projektbeschreibung}
VideoChop ist eine Webanwendung basierend auf JavaScript, die dem Anwender  ein einfaches und intuitives „Videoschnittstudio“ zur Verfügung stellt. VideoChop soll es ermöglichen Videos vom Desktop direkt in den Browser zu ziehen. Es steht dem User frei, ob er ein oder mehrere Videos schneiden oder zusammenfügen möchte. VideoChop wird eine übersichtliche und schlichte Oberfläche bieten, die auch Anfänger nicht überfordert. Die Videos werden in einer Zeitleiste organisiert und beschnitten. Wer mal eben schnell ein Video schneiden will, um Vor- oder Abspann oder etwaige Längen zu entfernen, braucht keine Speicher fressende und kompliziert zu bedienende Videobearbeitung. Der Nutzer kann sich sein Werk vor dem Abspeichern im Browser als Vorschau ansehen.
\subsection{Idee}
Die Idee ist es, dass VideoChop dem Nutzer eine Plattform zur Verfügung stellt, die keinerlei Daten serverbasiert speichert. Das Projekt basiert auf JavaScript und nutzt somit die Rechenressourcen des Nutzers. Die Belastung für den Server sind damit minimal. VideoChop soll einfach, intuitiv und schnell sein. JavaScript ist sehr mächtig, allerdings sind zu Projektbeginn die Möglichkeiten und Umsetzbarkeiten noch nicht geklärt.
\subsection{Zukunft}
Zukünftig sollen weitere Funktionalitäten hinzukommen. 
\begin{itemize}
	\item Audiospuren manipulieren
	\item Audio isolieren und neues Material auf Audio legen
	\item Webcam Recorder zum erstellen eigener Videos
	\item Export in verschiedene Formate
	\end{itemize}
\subsection{Probleme}
\begin{itemize}
	\item Das Verbinden mehrerer Videos zu einem mit Hilfe von JavaScript ist sehr problematisch.
	\item FFMPEG ist kein Javascript, sondern lediglich umgeskriptet, sodass man nicht alle Befehle wie in der Konsole ausführen kann
	\item Chrome liebt sein Aw... Snap! und das passiert sehr oft, wenn der Speicher voll wird
	\end{itemize}
\subsection{Was läuft gut?}
Alles! Wir sind im Zeitplan. Haben Spaß am Projekt und immer wieder noch mehr Ideen für die Umsetzung. Langsam aber sicher geht es jetzt an das Module schreiben.
\subsection{Was läuft nicht so gut?}
Zusammensetzen. Meistens schaffen wir es nur alle 3 in Skype zusammen zu kommen. Das liegt aber an unseren Nebenjobs und der Zeitplanung.
\subsection{Teamstruktur und Aufteilung?}
Jeder macht alles. Jeder macht das, wozu er Lust hat. Michael teilt sein Wissen aus seinem Entwickler-Job.
\newpage
\section{Mockup}
\textbf{mockup - mockup-vc-MD.pdf} \\
\includegraphics[height=225px, width=390px]{images/mockup.png}\\
\vspace*{1mm}
Das Mockup ist nur eine Orientierung für die finale Website.\\ 
\textbf{mockup - mockup-vc-md-Ideen-und-Kommentare.pdf} \\
\includegraphics[height=225px, width=390px]{images/mockup2.png}\\
Es wurde in Gruppenarbeit erstellt.
\newpage
\section{Testcases}
Für jede Funktion haben wir Testcases erstellt. Die Testcases werden jeweils nach Bedarf erweitert. Das bedeutet, dass im weiteren Verlauf der Entwicklung neue Testcases hinzukommen können. Die Testcases sind spezifisch und nicht modular programmiert. Aus den Testcases haben wir unsere Module abgeleitet.
\subsection{Canvas}
\textbf{testcases - canvas - index.html} \\
Allgemeiner Funtkionstest des Canvas Objekts.\\ 
\includegraphics[height=176px, width=300px]{images/canvas1.png}\\
\includegraphics[height=176px, width=300px]{images/canvas2.png}\\
Abbilden eines Videos auf einem Canvas Objekt. 
Wir wollten in diesem Test-Case versuchen ein Video auf einem Canvas abzuspielen. Wir hatten aber nicht im Blick, dass die Audiospur dann ja fehlt und das man jeden Frame des Videos nur als Bild aus dem Canvas speichern kann.
\subsection{Drag-Drop}
\textbf{testcases - drag-drop - index.html} \\
Der Drag and Drop Testcase dient als Grundlage für die spätere Timeline.\\
\includegraphics[height=176px, width=300px]{images/draganddrop.png}\\
Aus diesem Testcase wurde das Modul Video Timeline abgeleitet.\\
Es ist möglich neue Zeilen hinzu zu fügen und bestehende Leisten zu löschen.\\
Zudem kann man die hier farbigen Objekte, die spätere Videos darstellen sollen, innerhalb der leisten verschieben. Die Schritte in denen Verschoben wird, sprich die Größe des Grids ist einstellbar, damit wir später Stufenlos skalieren können.\\
Die Videos können in neue Zeilen gezogen werden, allerdings ist es nicht möglich, dass sich Videos überschneiden. 
\subsection{Video Export}
\textbf{testcases - export\_videos - index.html} \\
Dieser Test befasst sich mit der Möglichkeit Videos aus dem Browser zu exportieren. Wir haben versucht mit der Funktion toBlob() das aktuelle Bild, welches auf das Canvas gezeichnet wird, ein blob mit den Informationen in ein Array zu speichern. Dies hat funktioniert und wir konnten auch anschließend eine MP4-Datei exportieren. Jedoch konnte es nicht als Video abgespielt werden, da die gespeicherten Informationen nicht MP4-konform waren. Der filesaver hat demnach nicht zum gewünschten Ergebnis geführt in diesem Fall. Es konnte lediglich mit der Funktion toDataURL() das aktuelle Bild auf dem Canvas als URL gespeichert und angezeigt werden. \\
Durch das erfolgreiche Testen des Aneinanderfügens von zwei Videos und das zur Verfügung stellen als URL, benötigen wir das Canvas wahrscheinlich nicht mehr.
\subsection{Format Test}
\textbf{testcases - format-test - index.html} \\
Wir haben nur versucht ein Video per Drag \& Drop im Browser fallen zu lassen und es dann als HTML5-Video anzeigen zu lassen. Der Test war erfolgreich. WebM, MP4 und OGG können auf der Fläche platziert werden. Der Browser lädt das Video in den Cache und kann mittels createObjectUrl() das Video wieder in ein Source-Objekt verwandeln.
\newpage
\subsection{Video Concat}
\textbf{testcases - concat-videos - index.html} \\
Dieser Test sollte einzig dazu dienen zwei MPG-Videos mittels binärer Konkatenation zu einem Video zusammenzufügen. Der Test war erfolgreich. Das Projekt ist dadurch umsetzbar. Jetzt können wir 2 Videos aneinanderfügen. 
\subsection{FFMPEG}
\textbf{testcases - ffmpeg - index.html} \\
Das liebe FFMPEG bereitete am meisten Probleme. Dadurch, dass es eine Konsolen-Applikation ist und nicht natives Javascript mussten wir erstmal den Umgang mit Webworkern lernen und verstehen, wie man die Parameter richtig übergibt. Wir können Audio und Video separat rausrendern, sowie ein Dateiformat in ein anderes verwandeln. Die unterstützte Codec-Liste ist: http://bgrins.github.io/videoconverter.js/demo/ hier zu finden. Einfach auf List Codecs klicken und den Command ausführen.
\newpage
\subsection{Video Controls}
\textbf{testcases - video-controls - index.html} \\
Der Testcase Video Controls sollte die später benötigten Funktionen zum kontrollieren des Videos über JavaScript simulieren.\\ Folgende Funktionen wurden geschrieben und getestet : \\
\includegraphics[height=176px, width=300px]{images/videocontrols.png}\\
\begin{itemize}
	\item Button
	\begin{itemize}
		\item Play/Pause
		\item Stop
		\item Faster / Normal Speed
		\item Backward
		\item Mute
		\item Fullscreen
		\item Loop
	\end{itemize}
	\item Slides
	\begin{itemize}
		\item Volume
		\item Current Time
	\end{itemize}
	\item Timeupdate
	\begin{itemize}
		\item Display Current Time
		\item Display Duration Time
	\end{itemize}
\end{itemize}
Das Crossbrowser Testing hat ergeben, dass einige Funktionen noch einmal überarbeitet werden müssen.\\
Aus diesem Testcase wurde das Modul Video Controls abgeleitet. 
\newpage
\section{Module}
\subsection{Video Item}
\textbf{testcases - module\_video\_item - index.html} \\
\textbf{videochop - js - modules - videoItem.js} \\
Jedes vom Nutzer in den Browser gezogene Video wird duch ein VideoItem repräsentiert. Es speichert alle relevanten Daten. Die Daten werden beim in den Browser ziehen vom Modul VideoItemLoader ausgelesen und in ein neues VideoItem geschrieben.\\
\includegraphics[height=176px, width=375px]{images/videoitem.png}\\
Das Videoitem bekommt die Eigenschaften Video-URL, Name, Länge, Startpunkt, Endpunkt, Größe, Auflösung und Thumbnail übergeben oder es werden die Default-Settings gesetzt.
In der Funktion getMarkUp() werden die HTML-Felder in der index.html dann mit den Werten des VideoItems befüllt, um es in der VideoItemList entsprechend anzuzeigen. \\
\includegraphics[height=120px, width=375px]{images/videoitem2.png}\\
Die Größe und die Länge des Videos werden formatiert in den Funktionen timeFormat() und sizeFormat().

\subsection{Video Item Loader}
\textbf{testcases - module\_video\_item\_loader - index.html} \\
\textbf{videochop - js - modules - videoItemLoader.js} \\
Mit diesem Modul wird nach dem Drag and Drop eines Videos vom Desktop in den Browser hinein ein neues VideoItem erstellt und zurückgegeben.\\
Es gibt die Attribute data, extension, name, prettySize, size und type welche zunächst auf Default-Werte gesetzt sind.
Wird ein neuer VideoItemLoader instanziiert, muss die Funktion add() aufgerufen werden, welche aus dem übergebenen Video eine Video-URL erzeugt. In der Funktion wird dann die Funktion loadMetaData aufgerufen und bekommt diese URL übergeben. In der Funktion wird ein Video-HTML-Element erzeugt und die URL wird diesem hinzugefügt. Anschließend wird ein neues VideoItem erzeugt und zurückgegeben, welchem die Eigenschaften des aktuellen Videos übergeben werden.
\subsection{Video List}
\textbf{testcases - module\_video\_list - index.html} \\
\textbf{videochop - js - modules - videoList.js} \\
Das VideoList Modul stellt den Container für die VideoItems zur Verfügung.\\
\includegraphics[height=300px, width=200px]{images/videolist.png}\\
\subsection{Video Preview}
Dieses Modul wurde noch nicht programmiert.\\
Stellt den Container für die Video Preview zur Verfügung.
\subsection{Video Controls}
Dieses Modul wurde noch nicht programmiert.\\
Stellt alle Funktionen zum kontrollieren der Videos zur Verfügung.
\subsection{Video Timeline}
Dieses Modul wurde noch nicht programmiert.\\
Das Video Timeline Modul stellt sämtliche Funktionen für die spätere Video Timeline zur Verfügung. 
\newpage
\section{Zeitaufwand}
\begin{tabular}{|c|c|c|}\hline
	\textbf{Aufgabe} & \textbf{Zeitaufwand} \\ \hline
	
	Projektkonzept & 3 Stunden \\ \hline
	
	Einrichten Entwicklungsumgebung & 5 Stunden \\ \hline
	
	Installation \& Konfiguration IDE & 4 Stunden \\ \hline
	
	HTML-Struktur & 2 Stunden \\ \hline
	
	JS-Module Template & 1 Stunde \\ \hline
	
	Coding Conventions & 30 Minuten \\ \hline
	
	Test-Case: Canvas & 2 Stunden \\ \hline
	
	Mockup & 7 Stunden \\ \hline
	
	Test-Case: Drag\&Drop & 6 Stunden \\ \hline
	
	Test-Case: Video-Formate & 2 Stunden \\ \hline
	
	Test-Case: Video Controls & 2 Stunden \\ \hline
		
	Wiki: Lizenz prüfen & 1 Stunde \\ \hline
	
	Logo & 2 Stunden \\ \hline
	
	Test-Case: Video Controls Part II & 3 Stunden \\ \hline
	
	Content: Impressum & 1.5 Stunden \\ \hline
	
	HTML-Gerüst bauen & 6 Stunden \\ \hline
	
	Test-Case: Drag\&Drop Part II & 7 Stunden \\ \hline
	
	Video Controls: Cross Browser Test & 1 Stunde \\ \hline
	
	Dokumentation: IDE & 0.5 Stunden \\ \hline
	
	Test-Case: Drag\&Drop Part III & 3 Stunden \\ \hline
	
	Module: VideoItem & 3 Stunden \\ \hline
	
	Module: VideoList & 4 Stunden \\ \hline
			
	Module: VideoItemLoader & 3 Stunden \\ \hline
		
	Projektbeschreibung & 4 Stunden \\ \hline
	
	HTML-Gerüst: Timeline & 2 Stunden \\ \hline
	
	Test-Case: Video Part III & offen \\ \hline
	
	Test-Case: Canvas Part II & offen \\ \hline
	
	Module: Video Preview & offen \\ \hline
	
	Module: Video Controls & offen \\ \hline
	
	Module: Video Timeline & offen \\ \hline
	
	FFMPEG & 24 Stunden \\ \hline
 \end{tabular}
 \newpage
\section{Externe Plugins}
\subsection{jQuery Draggable}
URL: http://jqueryui.com/draggable/\\
Wird benutzt um DOM-Elemente browserübergreifend dragbar zu machen
\subsection{jQuery Droppable}
URL: http://jqueryui.com/droppable/\\
Wird benutzt um DOM-Elemente browserübergreifend auf bestimmten Elementen bestimmte Aktionen ausführen zu lassen.
\subsection{jQuery Collision}
URL: http://eruciform.com/static/jquidragcollide/jquery-ui-draggable-collision.js\\
Wird benutzt, damit zwei VideoItems in der Timeline nicht aufeinander liegen dürfen
\subsection{FFMPEG}
URL: https://github.com/bgrins/videoconverter.js\\
Wird benutzt um Videos umwandeln zu können.
\subsection{Popcorn JS Capture}
URL: https://github.com/rwaldron/popcorn.capture\\
Wird benutzt, um ein Poster von einem Video an einer beliebigen Position als Thumbnail zu extrahieren
\subsection{Filereader}
URL: https://github.com/bgrins/filereader.js/\\
Ein Plugin, die den Umgang mit Drag \& Drop von Dateien STARK vereinfacht
\subsection{UserAgent Parser}
URL: https://github.com/faisalman/ua-parser-js\\
Wird benutzt um festzustellen mit welchem Browser der User unterwegs ist
\subsection{FileSaver}
URL: https://github.com/eligrey/FileSaver.js\\
Hiermit können wir Dateien direkt auf dem Desktop des Users speichern, weil dieses Plugin die HTML5-Api ausbessert
\subsection{jQuery, Modernizr \& Require}
Dazu brauchen wir keine Beschreibung.

\newpage
\section{Quellen}
\end{document}